package ioutil

import (
	"io"
	ofs "io/fs"
	oos "os"

	. "github.com/kwitsch/gooswrap"
	"github.com/kwitsch/gooswrap/os"
)

// NopCloser returns a ReadCloser with a no-op Close method wrapping
// the provided Reader r.
func NopCloser(r io.Reader) io.ReadCloser {
	return io.NopCloser(r)
}

// ReadAll reads from r until an error or EOF and returns the data it read.
// A successful call returns err == nil, not err == EOF. Because ReadAll is
// defined to read from src until EOF, it does not treat an EOF from Read
// as an error to be reported.
func ReadAll(r io.Reader) ([]byte, error) {
	return io.ReadAll(r)
}

// ReadDir reads the directory named by dirname and returns
// a list of fs.FileInfo for the directory's contents,
// sorted by filename. If an error occurs reading the directory,
// ReadDir returns no directory entries along with the error.
func ReadDir(dirname string) ([]os.FileInfo, error) {
	fi, err := Wrapper.Util.ReadDir(dirname)
	return fromOosFilesInfo(fi), err
}

// ReadFile reads the file named by filename and returns the contents.
// A successful call returns err == nil, not err == EOF. Because ReadFile
// reads the whole file, it does not treat an EOF from Read as an error
// to be reported.
func ReadFile(filename string) ([]byte, error) {
	return Wrapper.Util.ReadFile(filename)
}

// TempDir creates a new temporary directory in the directory dir.
// The directory name is generated by taking pattern and applying a
// random string to the end. If pattern includes a "*", the random string
// replaces the last "*". TempDir returns the name of the new directory.
// If dir is the empty string, TempDir uses the
// default directory for temporary files.
// Multiple programs calling TempDir simultaneously
// will not choose the same directory. It is the caller's responsibility
// to remove the directory when no longer needed.
func TempDir(dir, pattern string) (string, error) {
	if len(dir) == 0 && Wrapper.IsVirtual() {
		dir = VirtualTempDir
	}
	return Wrapper.Util.TempDir(dir, pattern)
}

// TempFile creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting *os.File.
// The filename is generated by taking pattern and adding a random
// string to the end. If pattern includes a "*", the random string
// replaces the last "*".
// If dir is the empty string, TempFile uses the default directory
// for temporary files.
// Multiple programs calling TempFile simultaneously
// will not choose the same file. The caller can use f.Name()
// to find the pathname of the file. It is the caller's responsibility
// to remove the file when no longer needed.
func TempFile(dir, pattern string) (os.File, error) {
	if len(dir) == 0 && Wrapper.IsVirtual() {
		dir = VirtualTempDir
	}
	f, err := Wrapper.Util.TempFile(dir, pattern)
	return (os.File)(f), err
}

// WriteFile writes data to a file named by filename.
// If the file does not exist, WriteFile creates it with permissions perm
// (before umask); otherwise WriteFile truncates it before writing, without changing permissions.
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	return Wrapper.Util.WriteFile(filename, data, (ofs.FileMode)(perm))
}

func fromOosFilesInfo(ofi []oos.FileInfo) []os.FileInfo {
	res := make([]os.FileInfo, len(ofi))
	for i, fi := range ofi {
		res[i] = (os.FileInfo)(fi)
	}
	return res
}
